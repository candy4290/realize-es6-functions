// 1.滑动窗口
// 2.回溯
// 3.动态规划
// 4.排序
// 5.双指针
// 6.二叉树【递归思想-非常薄弱】
// 7.图

// 归并排序的时间复杂度是 O(n log n)

1.合并两个非严格递增的数组。s1、s2,合并后还要是递增数组，要求返回s1。
思路：从后往前。不需要额外空间

2.原地移除数组中元素。nums、val,返回nums中值不等于val的数量k，且要求nums前K个数中，没有值等于val。
思路：双指针，一个右指针从前往后遍历。一个左指针从0开始，遇到值不等于val的时候，赋值给左指针位置，且左指针向右移动。

3.删除有效数组中的重复项
给定一个非严格递增的数组，请你原地删除重复出现的元素，相同的元素最多只能出现两次。返回删除后数组的新长度
思路：双指针,一个右指针从前往后遍历。一个左指针从0开始，遇到值不等于前一个位置值的时候，赋值给左指针位置，且左指针向右移动。[从前往后遍历，也是从索引为0位置开始]

4.删除有效数组中的重复项II
给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使得出现次数超过两次的元素只出现两次 ，返回删除后数组的新长度。
不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。
思路：快慢指针。快指针每次往后遍历。nums[fast] !== nums[slow - 2]时候，nums[slow] = nums[fast],且慢指针向右移动


5.轮换数组，将数组中的元素，向右轮转K个位置，其中K>0。
思路：先将整个数组翻转，然后[0,k-1]翻转，[k，+00]翻转。

6.买卖股票的最佳时机。给定数组prices,索引i,表示第i天的价格。只可以买入、卖出一次。计算最大获利。
思路：一次遍历。记录当前数据中的最小值。如果当前指针数值小于最小值，则记录为最小值。否则计算该值与最小值的差值。

7.买卖股票的最佳时机II，给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。
在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。
返回 你能获得的 最大 利润 。
思路：1>动态规划 dp[i][0]表示第i天手里没有股票的最大收益，dp[i][1]其实第i天手里有股票的最大收益
dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1]+prices[i])
dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0]-prices[i]),最终返回dp[prices.length-1][0]
2>贪心，所有上涨的区间之和。

8.跳跃游戏。给你一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。
判断你是否能够到达最后一个下标，如果可以，返回 true ；否则，返回 false 。
思路：1>贪心。遍历数组，维护一个值表示可达的最远距离。如果当前索引小于最远距离，说明可以到达这一个位置。否则无法到达。遍历途中如果可达的最远距离大于等于数组长度，说明可以到达最后一个位置。
2>倒序遍历。
 int step = 1;  // 走到目标需要的步数
for (int i = nums.size() - 2; i >= 0; i--) {
    if (nums[i] >= step) {
    // 如果>=，代表从此元素可以达到
        step = 0;
    }
    step++;
}
return step == 1;

9.跳跃游戏II。基于上一个题目的背景，计算从第一个位置到达最后一个位置，需要跳跃的最少次数。
思路：贪心。遍历数组，维护一个值表示可达的最远距离。维护一个end。当遍历位置到达end时，需要走一步，并将end设置为当前记录的可达最远距离。【只需要遍历到倒数第二个，不需要遍历到最后一个。】

10.H指数。给你一个整数数组 citations ，其中 citations[i] 表示研究者的第 i 篇论文被引用的次数。计算并返回该研究者的 h 指数。
根据维基百科上 h 指数的定义：h 代表“高引用次数” ，一名科研人员的 h 指数 是指他（她）至少发表了 h 篇论文，并且 至少 有 h 篇论文被引用次数大于等于 h 。如果 h 有多种可能的值，h 指数 是其中最大的那个。
思路：倒序，然后从前往后遍历。提供变量ans,如果citations[i] > i,ans=i+1,返回ans.

11.除自身以外数组的乘积
给你一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 。
题目数据 保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在  32 位 整数范围内。
请 不要使用除法，且在 O(n) 时间复杂度内完成此题。

思路：左边数字乘积。右边数字乘积。然后得到结果

12.加油站
在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。
你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。
给定两个整数数组 gas 和 cost ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 保证 它是 唯一 的。
思路1：暴力破解[会超时]
思路2：

13.分糖果。
有一个数组表示每个同学的分数，每个同学至少分一个糖果。相邻同学分数高的，糖果一定要多一点。求最少要分多少糖果
输入：ratings = [1,0,2] 
输出：5
解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。

思路1：两次遍历，左规则一遍，右规则一遍, 且最少给一个糖果。然后取每个位置的最大值。
思路2：记录升序长度，降序长度。然后算出结果。

14.接雨水
给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。
输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
输出：6
解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 

思路：动态规划，两次遍历，获取每个位置左侧的最大值，获取每个位置右侧的最大值。每个位置的盛水量=Math.min(leftMax[i],rightMax(i))-height[i]。

14.给定字符串 s 和 t ，判断 s 是否为 t 的子序列。
字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，"ace"是"abcde"的一个子序列，而"aec"不是）。
思路: 双指针。一个在s上idx1,一个在t上idx2,每次idx2都向右移，遇到s[idx1] === t[idx2]，idx1也右移。如果最终idx1等于s的长度，说明“是”，否则“不是”

15.两数之和II-输入有序数组
给你一个下标从 1 开始的整数数组 numbers ，该数组已按 非递减顺序排列  ，请你从数组中找出满足相加之和等于目标数 target 的两个数。如果设这两个数分别是 numbers[index1] 和 numbers[index2] ，则 1 <= index1 < index2 <= numbers.length 。
以长度为 2 的整数数组 [index1, index2] 的形式返回这两个整数的下标 index1 和 index2。
你可以假设每个输入 只对应唯一的答案 ，而且你 不可以 重复使用相同的元素。
你所设计的解决方案必须只使用常量级的额外空间。
输入：numbers = [2,7,11,15], target = 9
输出：[1,2]
解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。返回 [1, 2]

思路：双指针。一个从前往后idx1，一个从后往前idx2。如果和大于目标值,idx2--。如果小于，idx1++。否则返回[idx1,idx2]

16.盛最多水的容器
给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。
找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。
返回容器可以储存的最大水量。
思路：双指针。一个从前往后idx1，一个从后往前idx2。如果arr[idx1]<arr[idx2],idx++,否则idx2--。

17.三数之和
给定一个整数数组nums,判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请你返回所有和为 0 且不重复的三元组。
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
思路：排序+双指针（两数之和）。主要是注意如何跳过相同值的元素

18.长度最小的子数组
给定一个含有 n 个正整数的数组和一个正整数 target 。
找出该数组中满足其总和大于等于 target 的长度最小的 子数组[numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组(连续的)，返回 0 。
 思路：滑动窗口。两个指针都指向0，如果和小于目标值。尾指针右移，否则左指针左移。

19.无重复字符的最长子串。给定一个字符串 s ，请你找出其中不含有重复字符的最长子串的长度。
思路：哈希表+滑动窗口[滑动窗口左指针移动时，需要删除哈希表对应区间的值]

-------矩阵--------
20.有效的数独
思路，用三个数组，分别记录每一行、每一列、每一个9宫格中1-9分别出现的次数。

21.螺旋矩阵。给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。
思路：
1>哈希表，记录每个访问过的节点。【也可以用m*n的数组标识】。遍历m*n次。4种方向。关键在于判断何时应该转换方向。
2>按层遍历，每次遍历最外层一圈，top+1,right-1,bottom-1,left+1, 条件top<=bottom,left<=right。

22.旋转图像
给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。
你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。
思路：1>第一行第一列的元素，旋转后出现在最后一列的第一行。公式matrix[col][n-row-1] = matrix[row][col];
原地置换，n是偶数的话，我们将二维数组切位4块，遍历左上角那一份就好n^2/4=(n/2)*(n/2)
n是奇数的话，同样的方法，且正中间那个元素保持不动。(n^2-1)/4=((n-1)/2)*((n+1)/2)
所以遍历时可以考虑行遍历到Math.floor((n+1)/2),列遍历到Math.floor(n/2);
思路：2>先水平翻转，再对角线翻转

-------哈希表--------
23.同构字符串
给定两个字符串 s 和 t ，判断它们是否是同构的。
如果 s 中的字符可以按某种映射关系替换得到 t ，那么这两个字符串是同构的。
每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。

输入：s = "egg", t = "add"
输出：true

输入：s = "foo", t = "bar"
输出：false

输入：s = "paper", t = "title"
输出：true

思路：两个哈希表，双射。一个记录s->t的映射关系，一个记录t->s的映射关系。

24.字母异位词分组
给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。
字母异位词 是由重新排列源单词的所有字母得到的一个新单词。
输入: strs = ["eat", "tea", "tan", "ate", "nat", "bat"]
输出: [["bat"],["nat","tan"],["ate","eat","tea"]]
思路：1>计数法。用长度为26的数组，记录每个字母出现次数。然后用这个数组的toString返回值做key，使用哈希表来存储对应的字符串数组。

25.存在重复元素 II
给你一个整数数组 nums 和一个整数 k ，判断数组中是否存在两个 不同的索引 i 和 j ，满足 nums[i] == nums[j] 且 abs(i - j) <= k 。如果存在，返回 true ；否则，返回 false 。

输入：nums = [1,2,3,1], k = 3
输出：true

输入：nums = [1,0,1,1], k = 1
输出：true

输入：nums = [1,2,3,1,2,3], k = 2
输出：false

思路1：哈希表
思路2：滑动窗口+Set/哈希表，窗口大小为k,如果这时候滑动窗口内有重复元素，返回true。

26.最长连续序列
给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。
请你设计并实现时间复杂度为 O(n) 的算法解决此问题。

输入：nums = [100,4,200,1,3,2]
输出：4
解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。

思路：先去重Set。然后遍历Set。然后看Set中x-1是否存在，不存在的话说明是开头的数据,然后看x+1是否存在，x+2。。。。
如果存在，说明x不是开头的数字，直接pass.
-------区间--------
27.合并区间
以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。
输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
思路：先按照左侧数字大小排序数组。然后合并重叠区间。

28.插入区间
给你一个 无重叠的 ，按照区间起始端点排序的区间列表 intervals，其中 intervals[i] = [starti, endi] 表示第 i 个区间的开始和结束，并且 intervals 按照 starti 升序排列。同样给定一个区间 newInterval = [start, end] 表示另一个区间的开始和结束。
在 intervals 中插入区间 newInterval，使得 intervals 依然按照 starti 升序排列，且区间之间不重叠（如果有必要的话，可以合并区间）。
返回插入之后的 intervals。
注意 你不需要原地修改 intervals。你可以创建一个新数组然后返回它。

输入：intervals = [[1,3],[6,9]], newInterval = [2,5]
输出：[[1,5],[6,9]]

思路1：先插入，再合并区间。
思路2：三种情况处理，一种是newInterval左侧的，一种是和newInterval有交叉区域，一种是都在newInterval右侧的。

29.用最少数量的箭引爆气球
有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 points ，其中points[i] = [xstart, xend] 表示水平直径在 xstart 和 xend之间的气球。你不知道气球的确切 y 坐标。
一支弓箭可以沿着 x 轴从不同点 完全垂直 地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被 引爆 。可以射出的弓箭的数量 没有限制 。 弓箭一旦被射出之后，可以无限地前进。
给你一个数组 points ，返回引爆所有气球所必须射出的 最小 弓箭数 。

输入：points = [[10,16],[2,8],[1,6],[7,12]]
输出：2
解释：气球可以用2支箭来爆破:
-在x = 6处射出箭，击破气球[2,8]和[1,6]。
-在x = 11处发射箭，击破气球[10,16]和[7,12]。

思路：按照右边界排序。选择第一个为标杆项， 后一项的左边界 如果<= 标杆项 的右边界，它们可以用一根箭射下来。

-------栈--------
30.有效的括号
给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。
思路：哈希表+栈，) -> (,....,字符在哈希表中不存在，则入栈。否则出栈，出栈的字符，需要对应哈希表中的value。

31.简化路径
给你一个字符串 path ，表示指向某一文件或目录的 Unix 风格 绝对路径 （以 '/' 开头），请你将其转化为 更加简洁的规范路径。
思路，以‘/’分割字符串成一个数组。+ 栈。

32.逆波兰表达式求值
输入：tokens = ["10","6","9","3","+","-11","*","/","*","17","+","5","+"]
输出：22
((10 * (6 / ((9 + 3) * -11))) + 17) + 5
思路：遇到数字入栈，遇到操作符出栈两个数字，运算后，将结果入栈。最终栈里应该只有一个元素。就是计算的最终结果。需要注意除法、减法，出栈到运算的前后顺序问题

-------链表--------

33.环形链表,判断是否有环
思路：快慢指针/哈希表

34.合并两个有序链表
将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 
思路：创建一个新链表。然后同时遍历两个链表。

35.随机链表的复制（深拷贝）
给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。
思路：两次遍历+哈希表；第一次遍历key-value,key为节点，value为新创建的节点。
第二次变量将哈希表(Map)中的value，构建成链表。

36.反转链表
给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。
思路：迭代+双指针。

37.反转链表II
给你单链表的头指针 head 和两个整数 left 和 right ，其中 left <= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。
输入：head = [1,2,3,4,5], left = 2, right = 4
输出：[1,4,3,2,5]
思路：将子区间切断，然后将其反转后再接回去（获取left的前一个节点 及 right节点）。使用虚拟头结点，因为第一个节点也可能参与反转。

38.删除链表的倒数第 N 个结点
思路1：快慢指针。快指针走到最后一个节点时，慢指针位置就是要删除节点的前一个位置；
思路2：两次遍历。第一次计算链表长度。第二次定位到要删除节点的前一个节点。
思路3：先遍历一次，全部入栈。然后再出栈的要删除的前一个节点。

39.删除排序链表中的重复元素 II【没写出来】
给定一个已排序的链表的头 head ， 删除原始链表中所有重复数字的节点，只留下不同的数字 。返回 已排序的链表 。
输入：head = [1,2,3,3,4,4,5]
输出：[1,2,5]
思路：一次遍历。因为头结点也可能被删除，使用一个哑节点。cur.next&&cur.next.next都不为空时，记录cur.next.val值。如果后续节点值都等于前面记录的值，则删除。

40.旋转链表
给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。
思路：先获取链表长度。然后连成环，再断开.

41.分隔链表
给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。
你应当 保留 两个分区中每个节点的初始相对位置。
思路：新建两个子链表。遍历原始链表一次，所有<x的，放到子链表1上，其余放子链表2上，然后将两个子链表连接起来。

42.LRU 缓存
请你设计并实现一个满足  LRU (最近最少使用) 缓存 约束的数据结构。
实现 LRUCache 类：
LRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存
int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。
void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。
函数 get 和 put 必须以 O(1) 的平均时间复杂度运行

思路：hash表+双向链表。使用过的，将其移动到最前面；需要借助于首尾哑节点。以便O(1)的复杂度
-------二叉树--------
43.二叉树的最大深度
思路1：深度优先+递归。每个位置的深度是max(left,right)+1;
思路2：借助于队列,进行广度优先检索。将每一层元素放到队列中去。每一次遍历都是取出一层的所有元素。
44.相同的树
给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。
如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。
思路1：深度优先+两次递归。
45.翻转二叉树
给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。
思路1：dfs,递归，先交互左右子树。然后递归他们的子节点。
思路2：dfs,递归，从叶子节点开始交换。
思路3：BFS+层序遍历+队列。
思路4：层序遍历
46.对称二叉树
给你一个二叉树的根节点 root ， 检查它是否轴对称。
思路1:递归【没理解递归解法】
思路2：层序遍历
47.中序遍历
思路1：递归。
思路2：迭代。遇到左节点就入栈，一直到为空时候，出栈，并放到结果集中。获取出栈的元素的右节点，然后重复上述步骤。
48.从前序与中序遍历序列构造二叉树
给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。
思路1：递归。前序数组中第一个肯定是根节点，然后在中序数组中找到根节点的索引。然后找出根节点左子树对应的前序、中序数组。右子树对应的前序、中序数组。递归下去。
49.填充每个节点的下一个右侧节点指针 II
填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL 。
初始状态下，所有 next 指针都被设置为 NULL 。
思路1：层序遍历。
思路2：不借助于额外空间。某一层如果next都构建完毕后，就形成了一个链表，为下一层构建next就不需要额外空间了。通过链表遍历当前层，且为下一层构建next;可以借助于一个哑节点来指向下一层节点的头部。
50.路径总和
给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。
叶子节点 是指没有子节点的节点。
思路1：递归，问下减小为，sum-root.val
51.二叉树的最近公共祖先
给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。
思路1：递归。root,l,r有这么几种情况，l,r在根节点root的两侧，则返回根节点root。否则，遍历到l或者r就可以返回，不继续往下。
思路2：构建指向parent的指针。
52.二叉树的右视图
给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。
思路1：层序遍历。每一层的最后一个元素。
-------二叉搜索树--------
53.二叉搜索树的最小绝对值
二叉搜索树：左子节点<根节点<右子节点
给你一个二叉搜索树的根节点 root ，返回 树中任意两不同节点值之间的最小差值 。
差值是一个正数，其数值等于两值之差的绝对值。
思路：中序遍历。
-------图--------
54.岛屿数量
给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。
岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。
此外，你可以假设该网格的四条边均被水包围。
思路：沉岛+DFS。
55.克隆图
给你无向 连通 图中一个节点的引用，请你返回该图的 深拷贝（克隆）。
思路：dfs+哈希表。哈希表用来记录已经出现的节点。
56.除法求值【无法完整写出题解】
输入：equations = [["a","b"],["b","c"]], values = [2.0,3.0], queries = [["a","c"],["b","a"],["a","e"],["a","a"],["x","x"]]
输出：[6.00000,0.50000,-1.00000,1.00000,-1.00000]
解释：
条件：a / b = 2.0, b / c = 3.0
问题：a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ?
结果：[6.0, 0.5, -1.0, 1.0, -1.0 ]
注意：x 是未定义的 => -1.0

思路：构建成一个图，使用邻接表+深度优先搜索+回溯+借助map来记录访问过的节点，避免环形死循环。[递归的方式实现深度优先，递->归，每次要开始递归之前，要确保节点还没有访问过。]

57.课程表
你这个学期必须选修 numCourses 门课程，记为 0 到 numCourses - 1 。
在选修某些课程之前需要一些先修课程。 先修课程按数组 prerequisites 给出，其中 prerequisites[i] = [ai, bi] ，表示如果要学习课程 ai 则 必须 先学习课程  bi 。
例如，先修课程对 [0, 1] 表示：想要学习课程 0 ，你需要先完成课程 1 。
请你判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回 false 。
输入：numCourses = 2, prerequisites = [[1,0]]
输出：true
解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。

输入：numCourses = 2, prerequisites = [[1,0],[0,1]]
输出：false
解释：总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。

思路：拓扑排序（把一个有向无环图 转成 线性的排序），有向图+入度数组+哈希表后续依赖课程+BFS（层序）；每次选课只能先选择入度为0的课程，没有前置依赖。
-------图广搜--------
58.蛇梯棋
给你一个大小为 n x n 的整数矩阵 board ，方格按从 1 到 n2 编号，编号遵循 转行交替方式 ，从左下角开始 （即，从 board[n - 1][0] 开始）的每一行改变方向。
输入：board = [[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,35,-1,-1,13,-1],[-1,-1,-1,-1,-1,-1],[-1,15,-1,-1,-1,-1]]
输出：4
解释：
首先，从方格 1 [第 5 行，第 0 列] 开始。 
先决定移动到方格 2 ，并必须爬过梯子移动到到方格 15 。
然后决定移动到方格 17 [第 3 行，第 4 列]，必须爬过蛇到方格 13 。
接着决定移动到方格 14 ，且必须通过梯子移动到方格 35 。 
最后决定移动到方格 36 , 游戏结束。 
可以证明需要至少 4 次移动才能到达最后一个方格，所以答案是 4 。

思路：1>根据编号，计算行号、列号。2>广度优先+队列（类似于层序遍历的方式）

59.最小基因变化
基因序列可以表示为一条由 8 个字符组成的字符串，其中每个字符都是 'A'、'C'、'G' 和 'T' 之一。
假设我们需要调查从基因序列 start 变为 end 所发生的基因变化。一次基因变化就意味着这个基因序列中的一个字符发生了变化。
例如，"AACCGGTT" --> "AACCGGTA" 就是一次基因变化。
另有一个基因库 bank 记录了所有有效的基因变化，只有基因库中的基因才是有效的基因序列。（变化后的基因必须位于基因库 bank 中）
给你两个基因序列 start 和 end ，以及一个基因库 bank ，请你找出并返回能够使 start 变化为 end 所需的最少变化次数。如果无法完成此基因变化，返回 -1 。
注意：起始基因序列 start 默认是有效的，但是它并不一定会出现在基因库中。

示例 1：
输入：start = "AACCGGTT", end = "AACCGGTA", bank = ["AACCGGTA"]
输出：1

示例 2：
输入：start = "AACCGGTT", end = "AAACGGTA", bank = ["AACCGGTA","AACCGCTA","AAACGGTA"]
输出：2

示例 3：
输入：start = "AAAAACCC", end = "AACCCCCC", bank = ["AAAACCCC","AAACCCCC","AACCCCCC"]
输出：3

思路：哈希+BFS

-------字典树--------
60.实现 Trie (前缀树)
Trie（发音类似 "try"）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补全和拼写检查。

请你实现 Trie 类：

Trie() 初始化前缀树对象。
void insert(String word) 向前缀树中插入字符串 word 。
boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。
boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。

思路：每个字母都是一个节点。构建成一个对象树。完整的单词在上面标记一个flag=true;
-------回溯--------【1.选择 2.约束（剪树） 3.目标】
61.电话号码的字母组合
给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。
给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

 const map = { '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz' };

输入：digits = "23"
输出：["ad","ae","af","bd","be","bf","cd","ce","cf"]

思路：哈希表+递归/回溯。

62.组合
给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。
你可以按 任何顺序 返回答案。

输入：n = 4, k = 2
输出：
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
思路1：回溯。为了避免重复选择，每次都是往后选择数字就好了。

63.组合总和
给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。
candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 
对于给定的输入，保证和为 target 的不同组合数少于 150 个。

输入：candidates = [2,3,6,7], target = 7
输出：[[2,2,3],[7]]。
思路：回溯【选择、探索(递归)、撤销选择】。能够选到自身，下一次可以从自身开始(为了避免重复)。其余和上一题基本一致。

64.括号生成
数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。
输入：n = 3
输出：["((()))","(()())","(())()","()(())","()()()"]

思路：剩下的左括号数量N1，剩下的右括号数量N2，N1>0就可以选左括号，N2>N1就可以选择右括号

65.单词搜索
给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。
单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
输出：true

思路：回溯。首先两层for循环遍历，遍历到的元素等于word的第一个单词时。进行递归、回溯操作。看能否从它出发，找到符合要求的单词。
-------分治--------
66.将有序数组转为二叉搜索树
给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵平衡二叉搜索树。

平衡二叉搜索树的任何结点的左子树和右子树高度最多相差1。

输入：nums = [-10,-3,0,5,9]
输出：[0,-3,9,-10,null,5]
解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：
思路：选取中间节点作为root根节点。左右子节点也适用同样的规则。

67.排序链表
给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。
输入：head = [4,2,1,3]
输出：[1,2,3,4]
思路：归并排序，时间复杂度nlog(n)。使用快慢指针及另一个额外指针，将链表一分为二。然后两个已排序的链表进行合并。

-------Kadane算法--------
68.最大子数组和
给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
子数组是数组中的一个连续部分。

Kadane算法：通过动态规划思维，以线性时间得到答案的算法。

思路：动态规划，f(i)表示以第i个数字结尾的子数组最大和。f(i) = Math.max(f(i-1)+num[i], nums[i]);

69.环形子数组的最大和
输入：nums = [1,-2,3,-2]
输出：3
解释：从子数组 [3] 得到最大和 3

输入：nums = [5,-3,5]
输出：10
解释：从子数组 [5,5] 得到最大和 5 + 5 = 10
思路1：两种情况。一种是i-j,0<=i<j<=n。第二种0-i,j-n。
思路2：获取最大子数组和及最小子数组和，分别对应了思路1的两种情况，这样也只需遍历一次。需要注意，如果子数组最大值小于0，则返回子数组最大值即口
-------二分查找--------
70.寻找峰值
峰值元素是指其值严格大于左右相邻值的元素。
给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。
你可以假设 nums[-1] = nums[n] = -∞ 。
你必须实现时间复杂度为 O(log n) 的算法来解决此问题
相邻元素不相等。

输入：nums = [1,2,3,1]
输出：2
解释：3 是峰值元素，你的函数应该返回其索引 2。

输入：nums = [1,2,1,3,5,6,4]
输出：1 或 5 
解释：你的函数可以返回索引 1，其峰值元素为 2；
     或者返回索引 5， 其峰值元素为 6。
思路：二分查找，注意，题目假设了两端都是无穷小的值。【往高处走】

71.搜索旋转排序数组
整数数组 nums 按升序排列，数组中的值 互不相同 。
在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。
给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。
你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。

示例 1：
输入：nums = [4,5,6,7,0,1,2], target = 0
输出：4

示例 2：
输入：nums = [4,5,6,7,0,1,2], target = 3
输出：-1

思路：相对于有序数组。这次的区别是左右两边肯定有一边是有序的。根据有序的部分判断target是否在其中。

72.在排序数组中查找元素的第一个和最后一个位置
给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。
如果数组中不存在目标值 target，返回 [-1, -1]。
你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。
 
示例 1：
输入：nums = [5,7,7,8,8,10], target = 8
输出：[3,4]

示例 2：
输入：nums = [5,7,7,8,8,10], target = 6
输出：[-1,-1]

思路： 两次二分，分别找最左边等于target的位置(找到等于target的位置，并保存住，然后右指针移动到该位置的左侧)，最右边等于target的位置（找到等于target的位置，并保存住，然后左指针移动到该位置的右侧）。

-------堆--------
73.数组中的第K个最大元素
给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。
请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。
你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。

输入: [3,2,1,5,6,4], k = 2
输出: 5

思路1：快排【分冶的思想(原地排序)】
思路2：堆排序【构建完全二叉树】【没掌握】

-------一维动态规划--------
74.打家劫舍
你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。

思路1：dp[i][1]表示偷第i间房的最大金额，dp[i][0]表示不偷这间房的最大金额，dp[i][1] = dp[i-1][0] + nums[i]，dp[i][0] = max(dp[i-1][0], dp[i-1][1])
思路2：
        # 若gp[i]表示直到第i间房的最大金额 
        # 首先明确dp[i][0] = gp[i-1]  因为第i个房间不偷的最大金额就等于第i-1个房间的最大金额
        # 则上面式子可以表示为
        # ① dp[i][1] = gp[i-2] + nums[i][因为dp[i-1][0] = max(dp[i-2][0],dp[i-2][1])==gp[i-2]]
        # ② dp[i][0] = gp[i-1]
        # 故gp[i] = max(dp[i][1],dp[i][0])= max(gp[i-2] + nums[i], gp[i-1])
        # 从而得到递推关系  

75.单词拆分
给你一个字符串 s 和一个字符串列表 wordDict 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 s 则返回 true。
注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。
输入: s = "leetcode", wordDict = ["leet", "code"]
输出: true

思路1：DFS，将字符串分割成两段，前一部分看是否存在于wordDict中，后面一部分看是否可以被wordDict中元素组成。可以考虑加入优化，缓存，避免重复计算。【DFS未完全独立写出】
思路2：动态规划。dp[i],取决于dp[j]及j-i是否存在于wordDict中。

76.零钱兑换
给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。
计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。
你可以认为每种硬币的数量是无限的。
输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
思路：对于这个题而言（以[1, 2, 5], 11为例），问题就转换成：
青蛙每次能跳 1 或 2 或 5 阶，跳到11阶有多少种跳法
相应的 11 阶的数量也就取决于跳到（ 第6阶、第9阶、第10阶 数量 ）中的最小值 + 1
f(n)=Math.min(f(n-1),f(n-2),f(n-5))+1

77.最长递增子序列
给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。
子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的
子序列。

输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
思路：dp(i)=Math.max(dp[j])+1,dp(i)表示以i结尾的最长递增序列

-------多维动态规划--------
78.三角形最小路径和
给定一个三角形 triangle ，找出自顶向下的最小路径和。
每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。
输入：triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]
输出：11（2+3+5+1）

思路1：f[i][j]表示从顶点0,0走到i,j的最小路径和。f[i][j] = Math.min(f[i-1][j-1],f[i-1][j]) + c[i][j]

79.不同路径II
给定一个 m x n 的整数数组 grid。一个机器人初始位于 左上角（即 grid[0][0]）。机器人尝试移动到 右下角（即 grid[m - 1][n - 1]）。机器人每次只能向下或者向右移动一步。
网格中的障碍物和空位置分别用 1 和 0 来表示。机器人的移动路径中不能包含 任何 有障碍物的方格。
返回机器人能够到达右下角的不同路径数量。
测试用例保证答案小于等于 2 * 109。

输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
输出：2

思路：dp[i][j]表示到达i,j的路径数量，dp[i][j] = dp[i-1][j]+dp[i][j-1],注意如果c[i][j] === 1,dp[i][j]就直接为0

80.最长回文子串
给你一个字符串 s，找到 s 中最长的回文子串。
输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。

思路1：中心扩散法。
思路2：动态规划。P(i,j) = P(i+1,j-1) && s[i] === s[j]

81.交错字符串
给定三个字符串 s1、s2、s3，请你帮忙验证 s3 是否是由 s1 和 s2 交错 组成的。
两个字符串 s 和 t 交错 的定义与过程如下，其中每个字符串都会被分割成若干 非空 
子字符串：
s = s1 + s2 + ... + s(n)
t = t1 + t2 + ... + t(m)
|n - m| <= 1
交错 是 s1 + t1 + s2 + t2 + s3 + t3 + ... 或者 t1 + s1 + t2 + s2 + t3 + s3 + ...
注意：a + b 意味着字符串 a 和 b 连接。

输入：s1 = "aabcc", s2 = "dbbca", s3 = "aadbbcbcac"
输出：true

思路1：dp[i][j],表示s1的前i个字符与s2的前j个字符，能否组成s3的前i+j个字符。dp[i][j] = dp[i-1][j] && s1[i-1] === s3[i+j-1] || dp[i][j-1] && s2[j-1] ===s3[i+j-1]

82.最大正方形
在一个由 '0' 和 '1' 组成的二维矩阵内，找到只包含 '1' 的最大正方形，并返回其面积。

输入：matrix = [["0","1"],["1","0"]]
输出：1

思路：动态规划，dp[i][j]表示以i,j为右下角的最大正方形边长。dp[i][j]=min(dp[i−1][j]),dp[i−1][j−1],dp[i][j−1])+1