1.tcp三次握手
全双工，需要确保客户端/服务端 能发送 并 对方可以收到，

1>客户端发送SYN（同步）包，表示请求建立连接，并携带一个初始序列号seq=x
2>服务端收到后，返回SYN-ACK（同步-确认）包，确认收到请求后，并告知自己的初始序列号seq=y,同时确认ack=x+1
3>客户端收到后，返回ACK（确认）包，确认ack=y+1,连接建立完成。

示意图：
客户端 -> 服务器: SYN(seq=x)
服务器 -> 客户端: SYN-ACK(seq=y, ack=x+1)
客户端 -> 服务器: ACK(ack=y+1)

意义:
1>保证通信双方都能收发数据（双向通信）
2>确认双方的初始序列号，防止数据错乱。
3>防止旧的连接请求包影响新的连接。

2.tcp四次挥手
1>客户端 发送 FIN（终止）包，表示不再发送数据，但仍能接收数据。
2>服务器 收到 FIN 后，返回 ACK，表示收到关闭请求，但可能仍有数据需要传输。
3>服务器 处理完剩余数据后，发送 FIN 关闭连接。
4>客户端 收到 FIN 后，返回 ACK，并等待一段时间（TIME_WAIT，2倍最大报文生存时间，通常是几十秒），确保服务器已收到后，正式关闭连接。

示意图：
客户端 -> 服务器: FIN(seq=a)       # 客户端请求断开
服务器 -> 客户端: ACK(ack=a+1)     # 服务器确认
服务器 -> 客户端: FIN(seq=b)       # 服务器请求断开
客户端 -> 服务器: ACK(ack=b+1)     # 客户端确认，进入 TIME_WAIT 状态

意义：
1>确保数据完整传输，避免数据丢失。
2>客户端 TIME_WAIT 保护机制。
TCP 的连接是基于 4 元组 (源IP, 源端口, 目标IP, 目标端口) 来识别的。
作用1，防止旧的 TCP 连接影响新连接。(如果连接刚关闭马上又用同样的4元组建立新连接，而旧连接的延迟数据还在路上，就可能“误入新连接”造成数据错乱。)
作用2，如果最后一个ACK丢失了，服务器会重发 FIN，客户端还能处理这个重发。
3>服务器优雅关闭，避免突然断开导致数据丢失。

3.TCP拥塞控制的4大算法阶段
1>慢开始
.初始时 cwnd（Congestion Window，拥塞窗口） = 1（单位是 MSS, 1MSS=1460字节，Maximum Segment Size，最大报文段大小）。
.每收到一个 ACK，就将 cwnd 加倍（指数增长）。
.当 cwnd ≥ 慢开始门限（ssthresh）时，进入拥塞避免阶段。
2>拥塞避免
.cwnd 不再指数增长，而是线性增长：每个 RTT 增加一个 MSS。
.保守地探测网络容量。
3>拥塞发生（超时或重传引发）
.如果出现超时或丢包（没收到 ACK）：
.ssthresh = cwnd / 2
.cwnd 重新设为 1（重新慢开始）
进入快速重传 / 快速恢复阶段（如启用）
4>快重传&快恢复
.连续收到 3 个重复 ACK，说明某个包丢了但网络没完全堵死。
.快速重传丢失包，不等超时。
.ssthresh = cwnd / 2，cwnd = ssthresh
.不进入慢开始，而是快速恢复

4.五层网络模型
应用层：定义了各种应用协议，如HTTP、FTP、SMTP等，应用层的协议规定了应用程序之间通信的方式和数据格式。
传输层：负责端到端的数据传输控制，提供数据传输服务，如FTP、UDP
网络层：负责在不同的网络之间，进行数据包的路由和转发。
数据链路层：负责将物理层传输的比特流组织成数据帧。
物理层：负责在物理介质上传输原始的比特流。

5.301,302,303
| 状态码 | 名称               | 是否永久 | 浏览器是否缓存 | 是否改变请求方法 | 常见使用场景                   |
|--------|--------------------|----------|----------------|------------------|--------------------------------|
| 301    | Moved Permanently  | ✅ 是     | ✅ 是（会记住）  | ❌ 否（保留原方法） | 域名迁移、SEO 优化             |
| 302    | Found              | ❌ 否     | ❌ 否           | ❌ 否（保留原方法） | 临时跳转、旧接口重定向         |
| 303    | See Other          | ❌ 否     | ❌ 否           | ✅ 是（强制用 GET） | 表单提交后跳转防止重复提交等   |

6.https
1>使用的TLS协议
2>TLS握手过程
    .客户端发起请求
        .支持的TLS协议版本
        .支持的加密算法列表
        .客户端随机数(Client Random)
    .服务器响应
        .选择的加密算法
        .SSL证书（含服务端公钥）
        .服务器随机数(Server Random)
    .客户端验证证书
        .浏览器用内置的CA列表校验证书是否合法、未过期、不是伪造的
        .验证通过，继续；否则显示“不安全”
    .客户端生成预主密钥
        .用服务端公钥加密“预主密钥”
        .发送给服务器
    .双方生成对称密钥
        .客户端和服务端根据：客户端随机数、服务端随机数、预主密钥，计算出相同的对称密钥
    .握手完成，开始加密通信