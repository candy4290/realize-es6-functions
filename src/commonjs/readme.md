### CommonJS 输出值的拷贝
### 然而在 ES6 模块中就不再是生成输出对象的拷贝，而是动态关联模块中的值。
### ES6 静态编译，CommonJS 运行时加载
### 无论是 ES6 模块还是 CommonJS 模块，当你重复引入某个相同的模块时，模块只会执行一次。--- 所以不会产生循环依赖，无限重复的问题
- import 命令会被 JavaScript 引擎静态分析，优先于模块内的其他内容执行。
- export 命令会有变量声明提前的效果。

CommonJS 模块输出的是值的拷贝(原始值的拷贝)，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。
- CommonJS 模块重复引入的模块并不会重复执行，再次获取模块直接获得暴露的 module.exports 对象
- 如果你要处处获取到模块内的最新值的话，也可以你每次更新数据的时候每次都要去更新 module.exports 上的值
- 如果你暴露的 module.exports 的属性是个对象，那就不存在这个问题了


## 模块化

### 早期的模块化
1>早期没有模块化；都是通过script标签来引入一个个文件。可能产生的问题有:变量、函数名冲突；全局变量太多的问题；模块与模块间依赖关系复杂不好管理；
|
2>为了解决这个问题，社区规范急需约定，一个文件只允许暴露一个全局对象，文件里所有属性都必须暴露在对象里面，以达到解决重复的问题；
|
3>紧接着社区又约定了一种IIFE,在前一种的形势下，在外层包裹了一层自执行函数。好处是：利用闭包特性，形成了私有变量，其次自执行函数可以传参，可以很好描述模块间的依赖关系，使得模块管理变得可行。

### 青铜器时代的模块化
受到commonjs规范影响，推出适合浏览器端的AMD规范，出现了requirejs这个符合AMD规范的库

### 现代模块化规范
ES6模块化